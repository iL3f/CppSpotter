%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Статический анализ}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Введение}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Статический анализ кода --- процесс выявления ошибок и недочетов в исходном коде без реального выполнения 
исследуемой программы. В большинстве случаев анализ производится над какой-либо версией исходного кода,
однако анализу может подвергаться объектный код. В основном данный термин применяют к анализу,
который производится автоматизировано, с использованием специального программного обеспечения.
В настоящее время статические анализаторы являются частью всех современных компиляторов. 
Найденные подозрительные участки кода компилятор выдает в виде предупреждений (warnings). 
Однако для того чтобы провести более детальный анализ исходного кода, необходимо больше процессорного времени и памяти. 
Поскольку компиляция должна происходить быстро, в компиляторах используются проверки только
на простые ошибки. Для выявления более сложных ошибок в исходном коде 
необходимо использовать специализированные инструменты для статического анализа кода.
В настоящее время статический анализ широко используется в областях:
\begin{itemize}
	\item ПО для медицинских устройств
	\item ПО для ядерных станций и систем защиты реактора
	\item ПО для авиации
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Решаемые задачи}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection {Выявление ошибок в программах}
Статический анализ в большинстве случаев используется для выявления ошибок в исходном коде.
Статический анализатор может быть как общего назначения, так и специализированным для поиска определенных 
классов ошибок. При исполльзовании статического анализа можно выявить значительное количество 
ошибок еще на этапе написания кода, что существенно снижает стоимость их исправления.
 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection {Рекомендации по оформлению кода}
Стив МакКоннелл (Steve McConnell) сказал в своём выступлении на SD West '04: <<код должен удобно 
читаться, а не удобно писаться>>\cite{sdWest}. Грамотное оформление кода крайне важное условие для людей, работающих
в одной команде. Следует помнить, что стиль и соглашения о форматировании 
у каждой организации свои. Обычно эти соглашения определяются на ранней стадии создании проекта.
В результате соблюдения принятых соглашений, код будет легче читаться и станет более единообразным 
и, как следствие, уменьшится стоимость поддержки и отладки существующего кода.  
Статический анализ для решения данной\cite{codeAssist} задачи применяют как для контроля уже давно работающих сотрудников,
так и для обучения новых, которые недостаточно хорошо знакомы с принятыми соглашениями.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection {Подсчет метрик}
Метрики кода представляют собой набор оценок программного обеспечения, которые дают разработчикам 
более глубокое представление о разрабатываемом коде.
Например с помощью метрик кода разработчики могут оценить сложность разработанного ПО,
понять какие места необходимо переработать или более тщательно тестировать. 
Примеры метрик:
\begin{enumerate}
	\item Колличественные метрики (количество строк кода, количество использованных операторов и др.)
	\item Связность
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection {Поиск уязвимостей}
Статический анализ можно успешно применять для поиска уязвимостей в ПО (Static Application Security Testting, SAST).
Однако не только разработчики программы могут использовать статический анализ. В случае, если
исходный код находится в открытом доступе или был украден, злоумышленники могут использовать 
статический анализ для нахождения потенциальных уязвимостей. Вместо того чтобы искать слабые
места программы вслепую или просматривать огромное количество исходного кода, куда проще провести статический анализ.
После нахождения слабых мест, злоумышленник может начать исследование слабых мест для атаки.
Хотя в большинстве случаев хакеру не доступен исходный код, все равно имеется возможность проведения 
статического анализа с помощью специальных анализаторов, которые работают с двоичным кодом.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection {Другие}
Перечисленные выше задачи --- не единственное применение для статического анализа. К примеру 
при написании кроссплатформенного кода довольно не просто учесть все особенности каждой ОС
или аппаратной платформы. На помощь в данном случае могут придти специализированные анализаторы,
которые смогут найти большинство небезопасных участков кода. 
Так же статический анализ можно использовать в обучении. Чтобы проверить работу ученика на ошибки
не нужно просматривать весь исходный код вручную, взамен можно автоматизировать проверку всех работ сразу.
Это очень удобно, когда у преподавателя много учеников и на ручную проверку всех работ уйдет
много времени. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Преимущества и недостатки}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Как и любой подход, статический анализ не является универсальным и имеет 
как преимущества, так и недостатки.
К преимуществам можно отнести:
\begin{itemize}
	\item Полное покрытие кода. 
	В отличии от динамического анализа, статические анализаторы проверяют даже те участки кода, 
которые получают управление крайне редко.

	\item Независимость от компилятора и среды выполнения.
	В виду того, что статический анализ производится над исходным кодом без реального выполнения,
появляется возможность находить скрытые ошибки. Данные ошибки могут появляться в определенных ситуациях 
и зависеть от реализации компилятора или заданных ключей компилятора. Примером скрытых ошибок могут
служить ошибки <<неопределенного поведения>> (англ. undefined behaviour).
	
	\item Возможность использования на ранних этапах жизненного цикла ПО.
	Основным преимуществом является возможность нахождения программных ошибок в программе на раннем этапе.
Вследствие чего происходит существенное уменьшение стоимости исправление ошибки. Так же данное 
преимущество удобно для проектов больших встраиваемых систем, в случае если невозможно
использовать средства динамического анализа  до тех пор, пока ПО не будет готово к запуску на целевой системе.

	\item Низкие стоимостные затраты. 
	Для того, чтобы использовать статический анализ, не нужно тратить дополнительные средства 
на создание тестовых программ или фиктивных модулей (stubs).    
\end{itemize}
Недостатки:
\begin{itemize}
	\item Ложные срабатывания.
	При поиске ошибок статический анализатор пытается предсказать поведение программы, используя
ее исходный код. Это приводит к тому, что происходит множество ложных срабатываний. В большинстве случаев 
подозрительный участок кода будет компилироваться и работать верно. Для определения является ли  
подозрительный участок кода ошибкой или нет, необходима помощь человек. В результате просмотр 
ложных срабатываний отнимает много времени и может отвлекать от просмотра участков кода, 
где есть реальная ошибка.
	
	\item Скорость.
	Поскольку для нахождения потенциальных ошибок необходимо проводить детальный анализ каждого
участка кода, анализ может занимать значительное время. Поэтому обычно статический анализ используется 
при <<ночных сборках>>.
	
	\item Статические анализаторы полностью не заменяют ручной аудит кода. 
	Такие категории дефектов, как логические ошибки, уязвимости и проблемы с производительностью,
могут быть обнаружены только экспертом или инструментами динамического анализа.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Существющие статические анализаторы}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Существует множество статический анализаторов кода, у каждого есть свои плюсы и минусы. 
Ниже будут рассмотрены некоторые из существующих анализаторов. С большим списком синтаксических
анализаторов можно ознакомиться на сайте Wikipedia\cite{analysWiki}.

\subsection{PVS-Studio}
PVS-Studio это статический анализатор для языка C/C++ отечетсвенной разработки. В нем можно 
выделить 4 набора правил для диагностики ошибок:
\begin{enumerate}
	\item Диагностика общего назначения
	\item Диагностика возможных оптимизаций
	\item Диагностика 64-битных ошибок (Viva64)
	\item Диагностика параллельных ошибок (VivaMP)
\end{enumerate}
Подробный список осуществляемых проверок можно найти на сайте PVS-Studio\cite{pvs}.

Одним из главным преимуществ является интеграция с Microsoft Visual Studio начиная с версии 2005.
При этом анализатор поставляется в виде плагина и для начала работы с анализатором не нужно
проводить настройку. Для удобства использования предоставляется пользовательский интерфейс для 
навигации по коду, анализа файлов и получения справочной информации. Также разработчиками реализована 
работа анализатора на многоядерных процессорах, что существенно ускоряет процесс нахождения ошибок.

Однако из преимуществ PVS-Studio вытекают и недостатки. Так как анализатору для работы необходима  
Visual Studio, то недостатками является:
\begin{itemize}
 \item Анализ можно производить используя только операционную систему Windows
 \item Для возможности использования плагинов не подходит бесплатная версия Visual Studio (Express)     
\end{itemize}

Хотя на сайте разработчиков есть описание того, как можно произвести запуск PVS-Studio на Linux, 
но официально нет поддержки Linux.

Для демонстрации возможностей PVS-Stduio разработчики постоянно проводят проверки проектов
с открытым исходным кодом. Со списком уже проверенных проектов и найденными ошибками можно 
ознакомиться на официальном сайте\cite{pvsopen}.

\subsection{Coverity}
Coverity является набором программ, которые используются для выявления и исправления дефектов безопасности
и качества в программах критического назначения. Одной из программ выявления дефектов является
статический анализатор Coverity Code Advisor умеющий находить дефекты и уязвимости в исходном коде, 
написанном на языке C,C++, Java и C\#.  

Отличительной особенностью Coverity является минимальное количество ложных срабатываний, большинство 
выдаваемых предупреждений действительно соответствует дефектным участкам кода, которые в последствии могут
привести к серьезным ошибкам.

Coverity Code Advisor может выявлять следующие дефекты:
\begin{itemize}
	\item Ошибки использования API
	\item Переполнение буффера
	\item Неправильная обработка ошибок
	\item Переполнения целлых типов данных
	\item Проблемы с производительностью
	\item Неинициализированные переменные
	\item SQL инъекции
	\item Разименование нулевого указателя
	\item Другие\cite{covall}
\end{itemize}
 
Недостатком данного анализатора является высокая цена, однако есть бесплатный онлайн сервис
Coverity Scan доступный для зарегистрированных open source проектов. Данный сервис начал сотрудничать
со Стенфордским университетом с 2006 года и в течении первого года было обнаружено и устранено
более 6000 программных ошибок в 50 С/С++ open source проектах\cite{covScan}. 

Статический анализатор Coverity использовали в ЦЕРНе для анализа программ, использующихся в 
большом адронном коллайдере\cite{covCern}. В результате было найдено и устранено более 40000 программных 
ошибок, которые могли повлиять на точность физических исследований частиц. Так же статический анализ
широко использовался во время разработки программного обеспечения для полета марсохода Curiosity\cite{covCur}.   
 
\subsection{Flint}
Flint --- это статический анализатор от компании Facebook с открытым исходным кодом\cite{flintGit} предназначенный 
для анализа программ написанных на С++. Изначально Flint был написан на языке С++, но затем 
был переписан на язык D, в следствии чего ускорилось время анализа исходного кода. 

Так как Flint разрабатывался для внутрених нужд компании, в качестве доступных проверок используются 
только часто встречающиеся ошибки:
\begin{enumerate}
	\item Запрет на идентификаторы из черного списока
	\item Инициализация переменной самой собой
	\item Все исключения должны передаваться по ссылке
	\item Ошибки при определении конструктора
	\item Передача небольших типов по значению
	\item Другие\cite{flintErr}
\end{enumerate}

Хотя Flint не сможет найти большинство ошибок как PVS-Studio или Coverity, большим достоинством
является открытость кода. Если необходимо добавить собственную проверку, это легко сделать.
  
\subsection{Clang Static Analyzer}
Clang Static Analyzer является инструментом для статического анализа, который находит ошибки
программ написанных на языке C,C++ и Objective-C. В данный момент имеется возможность использовать 
статический анализатор как отдельную программу или в интегрированной среде разработки XCode.
Отдельная программа запускается из командной строки и разработана для запуска вместе с компиляцией
исходного кода. Весь исходный код анализатора открыт и является частью проекта Clang. 
Анализатор реализован как С++ библиотека, которая может быть использована другими инструментами и приложениями.
 
В настоящее время ведется активная разработка и производятся постоянные улучшения как для повышения точности, 
так и для увеличения возможностей алгоритмов анализа. 

Доступные проверки разделены на 6 категорий: 
\begin{enumerate}
	\item Базовые проверки. Производятся проверки общего назначения, такие как деление на 0, 
разыменование NULL указателя, использование неинициализированных переменных и так далее
	\item С++ проверки. Сюда входят проверки, специфичные для языка С++
	\item Проверки для нахождения неиспользуемого кода.
	\item OS X проверки. Данные проверки необходимы для нахождения ошибок, специфичных для 
языка Objective-C и ошибок неправильного использования Apple SDK (OS X и iOS)
	\item Проверки безопасности. Используются для выявления небезопасного использования API. 
Производятся на основе CERT Secure Coding Standards 
	\item Unix проверки. Необходимы для проверки корректного использования Unix и POSIX API
\end{enumerate}
С полным списком доступных проверок можно ознакомиться на сайте анализатора\cite{clCheck}.

\subsection{Выводы}
Подводя итог вышесказанного, статический анализатор является удобным инструментом для поиска
ошибок. Проанализировав рассмотренные анализаторы, было принято решение создать статический анализатор,
который легко интегрировать в существующую среду сборки. Так же должна иметься возможность добавления новых 
проверок к уже реализованным.
