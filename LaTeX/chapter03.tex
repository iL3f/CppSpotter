%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Разработка модуля для Clang}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Список доступных проверок}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Одинковые условия}
Часто во время написания кода программист может допустить опечатку и не заметить следующюю
логическую ошибку: в исходном коде имеется оператор сравнения,логический или побитовый в левой 
и правой части которого находятся одинаковые выражения. 

Рассмотрим пример:
\begin{lstlisting}
if (pos.x==0 && pos.x==0)
\end{lstlisting}

В данном случае слева и справа от оператора "\&\&" расположены одинаковые выражения "pos.x==0",
что скорее всего свидетельствует о наличие ошибки, допущенной из-за невнимательности.

\subsection{Одинаковые ветки if-else}
if (a==0) 
{foo();} 
else 
{foo();}

\subsection{Одинаковые уловия у if-else-if}
if (a==0)
{...}
else if (a==0)
{...}

\subsection{Ошибки использования функции memset}
memset(buf,sizeof(buf),0)

int arr[10];
memset(arr, 0, 10);

\subsection{Неверный размер для выделения памяти под строку}
malloc(strlen(str)); // -> malloc(strlen(str) + 1)
new char[strlen(str)]; // -> new[strlen(str) + 1]

\subsection{Опечатка использования strlen}
strlen(str + 1);

\subsection{Потенциальная ошибка при использовании strcmp в условии}
 if (strcmp(...)) на if (strcmp(...) != 0)
 
\subsection{Одинаковые аргументы функций strcmp,strncmp,memmove,memcpy,strstr}
да

\subsection{Выражение внутри sizeof}
sizeof(A++);
sizeof(buf-1);
sizeof(buf*num);

\subsection{Перемножение sizeof на sizeof}
да 

\subsection{Выделение памяти для одного простого типа с инициализацией}
new int(n)
new char(n)

\subsection{Сравнение указателя и 0}
if (ptr < 0)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Диаграмма классов}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Тут будет приведена диаграмма классов и описано как классы взаимодействуют

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Динамическое подключение проверок}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Тут написать, что можно включать только необходимые проверки и делается это с помощью флагов 
для плагина.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Нахождение ошибки}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Тут будет описание того, что каждый класс при вызове функции addToFinder
добавляет необходимый astmacther и callback для обработки результата.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Добавление новых проверок}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Тут рассказать, что для добавления новой проверки нужно создать новый класс, написать astMacther
и не забыть добавить в matchFinder