%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Компилятор clang и модули расширения}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Введение}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Clang\cite{clang} является компилятором для языков программирования C, C++, Objective-C, Objective-C++ и OpenCL.
Для оптимизации исходного кода и кодогенерации используется фреймворк LLVM\cite{llvm}. Хотя Clang разрабатывается
как фронтенд для LLVM, теоретически возможно использовать и другие бэкенды. К примеру в качестве бэкенда
можно использовать GCC. Однако комбинация Clang и LLVM предоставляет набор инструментов, 
позволяющий полностью заменить GCC. 

Разработка Clang началась ввиду того, что был необходим компилятор, который предоставлял бы 
детальные диагностики ошибок, удобную интеграцию с интегрированной средой разработки и имел бы
лицензию, позволяющую использовать компилятор в коммерческих целях. В результате в 2007 году был 
представлен компилятор Clang под лицензий University of Illinois/NCSA Open Source License.
Для интегрированной среды разработки XCode, Clang становится основным компилятором начиная с версии 3.2.
С ноября 2012 года в качестве основного компилятора для FreeBSD используется Clang. Вероятно в ближайшие годы
Clang сменит GCC и будет основным компилятором для языков С и С++ во многих диструбутивах и
других Unix-подобных системах.

Одной из главных целей Clang является поддержка инкрементной компиляции, которая позволяет более
тесно интегрировать компилятор и среду разработки. Для GCC это непросто 
сделать так как он разрабатывался для использования в классическом цикле <<компиляция-линковка-отладка>>.
Поэтому Clang стремится предоставить фреймворк, позволяющий производить парсинг, индексацию, 
статический анализ и компиляцию языков семейства C. 

Ввиду того, что изначально Clang был спроектирован для максимального сохранения информации во время 
процесса компиляции, появляется возможность предоставлять контекстно-ориентированные сообщения об ошибках.
Такие сообщения понятны программистам и удобны для сред разработки. Так же благодаря 
модульности дизайна компилятора, можно использовать необходимые модули в среде разработки для
индексирования кода, подсветки синтаксиса и рефакторинга.

Подводя итог выше сказанного, можно выделить основные цели использования Clang:
\begin{itemize}
\item Особенности для конечного пользователя:
\begin{itemize}
\item Быстрая компиляция и небольшое использование памяти.
\item Понятные диагностики.
\item Совместимость с GCC.
\end{itemize}

\item Преимущества для приложений:
\begin{itemize}
\item Модульная архитектура.
\item Поддержка разнообразных инструментов (рефакторинг, статический анализ, генерация кода и так далее).
\item Тесная интеграция с средой разработки.
\item Использование BSD-подобной лицензии.
\end{itemize}

\item Внутренний дизайн и реализация:
\begin{itemize}
\item Простой и легко изменяемый исходный код.
\item Унифицированный парсер для языков С, Objective-C, C++ и Objective-C++.
\item Поддержка последних версий C/C++/Objective-C.
\end{itemize}
\end{itemize}

С полным и подробным списком всех особенностей можно ознакомиться на сайте Clang\cite{clangFea}.

Clang разработан как набор библиотек, которые могут быть использоваться независимо друг от друга. 
К примеру, если необходимо создать препроцессор, достаточно использовать библиотеки <<Basic>> и <<Lex>>.
Для инструментов рефакторинга или статического анализа есть библиотеки для получения абстрактного синтаксического 
дерева. 

В данной работе будет производится анализ на основе абстрактного синтаксического дерева. 
В отличии от GCC и TCC, Clang предоставляет средства для получения абстрактного синтаксического
дерева в несокращенном виде, что особенно удобно для разрабатываемого модуля статических проверок.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Структура абстрактного синтаксического дерева Clang}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Абстрактным синтаксическим деревом (Abstract Syntax Tree) называется представление исходного кода 
в виде дерева, в котором вершинами являются операторы языка программирования, а листьями - операнды.
Листья могут представлять только переменные и константы. 

Узлы в абстрактном синтаксическом дереве Clang организованы так, что у них нет общего предка.
Вместо этого, есть несколько больших иерархий классов для простых типов, таких как {\em Decl} и {\em Stmt}.
\begin{itemize}
	\item Decl представляет объявления (declarations). От данного класса наследуются разнообразные
объявления типов. К примеру класс FunctionDecl отвечает за объявление функции, а класс ParmVarDecl 
за объявление параметра функции.
	\item Stmt представляет операторы (statements). Все классы, описывающие операторы, наследуются
от данного класса. К примеру для оператора <<if>> существует класс IfStmt, оператору <<return>> 
соответствует класс ReturnStmt. 
\end{itemize}
Многие важные AST узлы наследуются от классов {\em Type, Decl, DeclContext} или {\em Stmt}, а некоторые классы 
наследуются от {\em Decl} и {\em DeclContext}. В Clang AST выражения (expressions) представляются классом Expr,
наследуются от класса Stmt и являются операторами. Однако существует множество классов, 
которые не являются частью большой иерархии классов и доступны только из определенных узлов, 
к примеру класс CXXBaseSpecifier. Так же важно помнить, что комментарии не входят в состав 
абстрактного синтаксического дерева.

Все информация о абстрактном синтаксическом дереве для единицы трансляции (translation unit)
собрана в классе ASTContext. Он представляет обход всей единицы трансляции или доступ к таблице
идентификаторов Clang для разобранной единицы трансляции. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Способы использования Clang}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Clang предоставляет необходимую инфраструктуру для создания инструментов, которым необходима
синтаксическая и семантическая информация из исходного кода. Для того, чтобы использовать все 
возможности Clang есть три способа создания инструментов: использование библиотеки LibClang, 
использование библиотеки LibTooling или создание плагина для Clang. Рассмотрим каждый из методов.

\subsection*{LibClang}
LibClang представляет стабильный высокоуровневый интерфейс к Clang, написанный на языке С. 
Является хорошим выбором если необходим стабильный API, так как Clang периодически меняется.
В случае если использовать LibTooling или создавать плагин, то нужно обновлять написанный код,
чтобы он соответствовал изменениям в Clang. Так же LibClang позволяет использовать другие языки
программирования для доступа к Clang API, а не только С++. Однако LibClang не предоставляет полного доступа к 
абстрактному синтаксическому дереву. Для работы с Clang предоставляется небольшой набор типов и функций,
посредством которых происходит взаимодействие с ядром. Поэтому многие средства недоступны или 
предоставляются в урезонном виде.

\subsection*{LibTooling}
LibTooling это С++ интерфейс, используемый для написания приложения. Типовые примеры использования
LibTooling:
\begin{itemize}
	\item Простое приложение для проверки синтаксиса
	\item Инструменты рефакторинга
\end{itemize}
 
В отличии от LibClang, предоставляется полный доступ к абстрактному синтаксическому дереву. 
Анализировать можно как один файл, так и заданный набор файлов, независимо от системы сборки.

Примерами использования LibTooling являются Clang Tools. Clang Tools --- это коллекция специальных 
инструментов для разработчика, используемых для автоматизации и улучшения разработки на языках C и C++.
Примеры созданных или планируемых инструментов как часть проекта Clang:
\begin{itemize}
	\item Проекра синтаксиса (clang-check)
	\item Автоматическое исправление ошибок компиляции (clang-fixit)
	\item Автоматическое форматирование кода (clang-format)
	\item Инструменты для миграции кода под новый стандарт языка (clang-modernize)
	\item Инструменты для рефакторинга
\end{itemize}

\subsection*{Модуль расширения для Clang}
Использование плагина для Clang позволяет производить дополнительные действия при обходе абстрактного 
синтаксического дерева как часть процесса компиляции. Плагины представляют собой динамические
библиотеки, которые могут подключаться к компилятору во время выполнения. Благодоря динамическому подключению 
к компилятору, плагин легко интегрировать в среду сборки проекта. Так же плагин имеет возможность 
останавливать процесс сборки. Как и при использовании LibTooling, плагину предоставляется полный
контроль над абстрактным синтаксическим деревом.
 
Однако стоит помнить, что нецелесообразно создавать плагин, если:
\begin{itemize}
	\item Необходимо использовать плагин вне среды сборки
	\item Необходимо использовать плагин для определенного набора файлов в проекте, которые 
не обязательно вызывают пересборку проекта
\end{itemize}

\subsection*{Выводы}
Как видно из проведенного анализа методов взаимодействия с Clang, самым удобным спосбом является создание
модуля расширения. Для интеграции в существующую среду разработки достаточно подключить созданный модуль.
Также модулю расширения предоставляется полный доступ ко всем возможностям ядра Clang.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Выявление фрагментов кода на основе AST}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Чтобы найти фрагменты кода, содержащие ошибку, будем использовать абстрактное синтаксическое дерево.
Для выявления ошибок необходимо найти все совпадения узлов, соответсвующих фрагменту кода с ошибкой, в
абстрактном синтаксическом дереве. Для обхода и нахождения интересующих мест в абстрактном 
синтаксическом дереве Clang есть два подхода:
\begin{itemize}
	\item RecursiveASTVisitor
	\item ASTMatcher
\end{itemize}

Рассмотрим как с помощью каждого подхода найти интересующий фрагмент кода. В качестве примера
будет рассмотрено нахождение фрагмента кода, содержащий оператор if и в качестве условия 
происходит сравнение указателя и 0:
\begin{lstlisting}
int main()
{
	int var = 5;
	int *ptr = &var;
	if (ptr < 0) // <==
		var++;
	return 0;
}
\end{lstlisting}

Абстрактное синтаксическое дерево для интересующего фрагмента кода:
\begin{lstlisting}[basicstyle=\tiny]
-IfStmt 0x7fdb75024790 <line:18:2, line:19:6>
|-<<<NULL>>>
|-BinaryOperator 0x7fdb75024720 <line:18:6, col:12> 'int' '<'
| |-ImplicitCastExpr 0x7fdb750246f0 <col:6> 'int *' <LValueToRValue>
| | `-DeclRefExpr 0x7fdb750246a8 <col:6> 'int *' lvalue Var 0x7fdb750245f0 
'ptr' 'int *'
| `-ImplicitCastExpr 0x7fdb75024708 <col:12> 'int *' <NullToPointer>
|   `-IntegerLiteral 0x7fdb750246d0 <col:12> 'int' 0
|-UnaryOperator 0x7fdb75024770 <line:19:3, col:6> 'int *' postfix '++'
| `-DeclRefExpr 0x7fdb75024748 <col:3> 'int *' lvalue Var 0x7fdb750245f0 
'ptr' 'int *'
`-<<<NULL>>>
\end{lstlisting}

\subsection{RecursiveASTVisitor}
Класс RecursiveASTVisitor позволяет обойти каждую вершину абстрактного синтаксического дерева.
Для этого необходимо создать класс, который будет отвечать за обход абстрактного синтаксического 
дерева. Данный класс должен наследоваться от класса RecursiveASTVisitor. Чтобы обойти интересующие вершины
типа {\em NodeType},
достаточно переопределить функцию <<bool VisitNodeType(NodeType *)>>. Так для обхода всех Stmt 
необходимо переопределить функцию <<bool VisitStmt(Stmt *)>>. Так же можно переопределить функцию
для поиска вершин, которые являются подклассами Stmt. К примеру для нахождения оператора <<if>>
нужно переопределить функцию <<bool VisitIfStmt(IfStmt *)>>. В этом случае для оператора <<if>> 
будет вызываться два обработчика: VisitStmt и VisitIfStmt.

Для Visit* функций необходимо возвращать значение <<true>>, чтобы продолжить обход остальных вершин
абстрактного синтаксического дерева. Если же возвратить значение <<false>>, обход дерева полностью
прекращается и Clang завершает работу.

Рассмотрим как стоит использовать RecursiveASTVisitor для нахождения участка кода из вышеописанного
примера. Проанализировав полученное для исходного кода абстрактное синтаксическое дерево видно, что 
корнем для искомого фрагмента является IfStmt. Поэтому в классе, созданном для обхода AST
следует переопределить функцию с именем "VisitIfStmt". Так же нетрудно заметить, что условием 
оператора "if" должен быть оператор сравнения (BinaryOperator), в котором в левой части
находится указатель, а в правой константа, равная 0. Между левой и правой частью оператора сравнения
должен быть символ <<\textless>>. Основываясь на вышесказанном, можно написать код для выявления заданного шаблона.
\begin{lstlisting}
class Example:
	public RecursiveASTVisitor<Example> 
{
public:
bool VisitIfStmt(IfStmt *s) {
  if (const BinaryOperator *binOP =
    llvm::dyn_cast<BinaryOperator>(s->getCond())) 
  {
    if (binOP->getOpcode() == BO_LT) 
    {
      const Expr *LHS = binOP->getLHS();
      if (const ImplicitCastExpr *Cast =
            llvm::dyn_cast<ImplicitCastExpr>(LHS)) 
      {
        LHS = Cast->getSubExpr();
      }
      
      const Expr *RHS = binOP->getRHS();
      if (const ImplicitCastExpr *Cast =
            llvm::dyn_cast<ImplicitCastExpr>(RHS)) 
      {
        RHS = Cast->getSubExpr();
      } 

      if (const DeclRefExpr *dRef=
			llvm::dyn_cast<DeclRefExpr>(LHS) &&
		  const IntegerLiteral *intVal = 
			llvm::dyn_cast<IntegerLiteral>(RHS)) 
	  {
        if (const VarDecl *Var =
        llvm::dyn_cast<VarDecl>(dRef->getDecl())) 
        {
          if (Var->getType()->isPointerType() &&
            intVal->getValue().getZExtValue() == 0) 
          {
            s->dump();  // found
          }
        }
      }
    }
  }
  return true;
}
};
\end{lstlisting}

Как видно для нахождения простого шаблона нужно написать довольно много кода. Главной проблемой 
является то, что данный код трудно читать. Чтобы понять, какой шаблон ищет приведенный код,
необходимо вчитываться и смотреть, что делает каждая строчка кода. 


\subsection{ASTMatcher}
С недавного временив Clang появилась библиотека ASTMatcher, которая предоставляет простой, мощный и
краткий способ определять шаблоны в абстрактном синтаксическом дереве. Реализованные как
предметно ориентированный язык на основе макросов и шаблонов, matchers\footnote{Matchers~--- шаблоны абстрактного синтаксического дерева Clang, созданные с использованием библиотеки ASTMatcher} 
похожи на алгебраические типы данных\footnote{Алгебраический тип данных~--- тип данных получаемый из других типов с помощью алгебраических операций} 
из функциональных языков программирования.

К примеру для исследования только бинарных операторов есть matcher который делает именно это и называется 
"binaryOperator". Для того, чтобы исследовать только бинарный оператор, в левой части у которого 
используется литера 0, необходимо написать следующий matcher: 
\begin{lstlisting}
binaryOperator(hasLHS(integerLiteral(equals(0))))
\end{lstlisting}
Данный matcher не будет находить фрагменты кода, где используются другие формы 0, такие как '\textbackslash0',
но matcher будет работать, если используется макрос, который раскрывается в 0. Matcher так же 
не будет срабатывать если используется перегруженный бинарный оператор, так как для этого 
есть специальный matcher, который называется "operatorCallExpr" и используется для обработки 
перегруженных операторов. 

Есть три простых категории для matchers:
\begin{enumerate}
	\item \textit{Node Matchers.} Используются для поиска в AST по определенному типу. Любой шаблон
определяющий выражение должен начинаться с Node Matcher, который затем можно уточнить с помощью
Narrowing Matcher или Traversal Matcher. Все Traversal Matcher используют Node Matcher в качестве аргументов.
Так же только Node Matcher имеют метод "bind" для связывания заданного узла и имени, для того чтобы в дальнейшем
можно было получить найденный узел по имени.
	\item \textit{Narrowing Matchers.} Используются для поиска по атрибутам вершины абстрактного
синтаксического дерева. Есть специальные логические Narrowing Matchers (allOf, anyOf, anything и unless) 
которые позволяют пользователям составлять более сложные выражения. 
	\item \textit{Traversal Matchers.} Используются для нахождения узла по связям между узлами 
абстрактного синтаксического дерева. Есть специальные Traversal Matchers которые работают для 
всех узлов и позволяют пользователям писать более универсальные выражения.
\end{enumerate}

Если Matcher описывает сущность в абстрактном синтаксическом дереве Clang и может быть 
связан с именем, то на него можно получить ссылку когда шаблон найден. Для этого нужно
вызвать метод "bind" на нужном шаблоне. К примеру следующий шаблон находит все переменные типа
int и связывает с этой переменной имя "intVar":
\begin{lstlisting}
variable(hasType(isInteger())).bind("intVar")
\end{lstlisting}

Для обработки фрагментов кода, удовлетворяющих заданному шаблону необходимо создать класс обработчик.
Данный класс должен наследоваться от класса MatchCallback. У класса MatchCallback есть три функции, 
которые можно переопределить:
\begin{enumerate}
	\item \textbf{void run(const MatchResult \&Result)}. Является обязательной для переопределения.
Вызов данной функции происходит каждый раз, когда был найден участок кода, соответствующий
заданному шаблону
	\item \textbf{void onStartOfTranslationUnit()}. В отличии от функции "void run(const MatchResult \&Result)"
данная функция не является обязательной для переопределения. Вызывается каждый раз в начале
разбора для каждой единицы трансляции
	\item \textbf{void onEndOfTranslationUnit()}. Функция "void onEndOfTranslationUnit()"
аналогична ранее рассмотренной функции "void onStartOfTranslationUnit()" с единственным отличием,
что вызывается каждый раз в конце разбора для каждой единицы трансляции.
\end{enumerate}

Как видно из заголовка функции "run", в качестве параметра данной функции передается ссылка
на результат {\em MatchResult}. Данный класс необходим для получения всей информации при
совпадении абстрактного синтаксического дерева с заданным шаблоном. 

За работу по нахождению участков кода, соответствующих заданному шаблону отвечает класс
MatchFinder. Для регистрации обработчика и шаблона, который данный обработчик будет анализировать
необходимо использовать функцию \textit{addMatcher}. Первым параметром данной функции является 
шаблон который необходимо выявить в абстрактном синтаксическом дереве. Вторым параметром необходимо
передать указатель на экземпляр класса обработчика. 

Рассмотрим нахождение участка кода из вышеописанного примера нахождения сравнения указателя
и 0 с использованием ASTMatcher.

Как уже было рассмотрено ранее, корнем для искомого фрагмента кода должен быть IfStmt обозначающий
оператор "if". Затем условием оператора "if" должен быть оператор сравнения (BinaryOperator), 
в левой части которого находится указатель, а в правой литера 0. В результате AST matcher будет
выглядеть следующим образом: 
\begin{lstlisting}
ifStmt( hasCondition( binaryOperator(
	hasOperatorName("<"),
	hasLHS(ignoringParenImpCasts(declRefExpr(
    to(varDecl(hasType(pointsTo(AnyType))))))),
    hasRHS(ignoringParenImpCasts(
    	integerLiteral(equals(0))))
    ))).bind("if")
\end{lstlisting}
Большинство типов понятны из названия, тип {\em ignoringParenImpCasts} необходим для
игнорирования неявных приведений типа. 
Обработчик, вызываемый при нахождении данного совпадения выглядит так:
\begin{lstlisting}
class Example:
public MatchFinder::MatchCallback 
{
public:
void run(const MatchFinder::MatchResult &Result) 
{
const IfStmt *s = 
	Result.Nodes.getNodeAs<clang::IfStmt>("if");
    if (s)
      s->dump();
  }
};
\end{lstlisting}

Как видно необходимо писать намного меньше кода, чем при использовании RecursiveASTVisitor,
вследствии чего труднее допустить ошибки. Так же важным преимуществом использования AST Matcher
является наглядность. Увидев такой шаблон, можно сразу понять какому фрагмента кода он соответствует. 
Поэтому в разрабатываемом модуле статических проверок используется данный подход.

\section{Создание модуля расширения}
Модуль расширения представляет собой FrontendActions, который позволяет исполнять код, написанный 
пользователем, как часть процесса компиляции, умеющий обрабатывать флаги командной строки. 
Для создания плагина необходимо выполнить 3 условия:
\begin{enumerate}
	\item Создать класс, отвечающий за выполнение действия в процессе компиляции.
Для модуля расширения необходимо чтобы данный класс наследовался от {\em PluginASTAction}.
	\item Переопределить функцию {\em CreateASTConsumer}. Эта функция должна возвращать 
экземпляр класса ASTConsumer. Класс ASTConsumer используется для обхода абстрактного синтаксического дерева.
	\item Зарегестрировать модуль расширения. Для регистрации модуля расширения с именем <<CppSpotter>>
вызывается функция 
\begin{lstlisting}
static clang::FrontendPluginRegistry::Add<CppSpotterASTAction>
X("CppSpotter", "Cpp Error Spotter");   
\end{enumerate}
\end{lstlisting}

Так как было принято решения использовать библиотеку ASTMatcher для нахождения фрагментов кода,
необходимо создать экземпляр класса {\em MatchFinder}. В дальнейшем в данном классе будут регистрироваться шаблоны
для проверок.