%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Тестирование разработанного модуля}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Тестирование}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
В результате тестирования созданного модуля были выявленны некоторые ошибки первого и второго рода. 

\subsection*{Ошибки первого рода}
Так как анализатор выдает предупреждения, если найдены участки кода, в которых слева и справа от оператора
находятся одинаковые выражения (см. \ref{sec:eqBin}), то следующий код вызывает подозрение у анализатора: 
\begin{lstlisting}
*++scan == *++match && *++scan == *++match
\end{lstlisting}
Однако данный код является корректным, так как переменные в левой части изменяются, после чего переменные
в правой части имеют измененные значения. Так же данное ложное срабатывание будет происходить при
вызове функции, которая меняет свое состояние или глобальные переменные:
\begin{lstlisting}
bool foo()
{
	static bool initialized = false;
	if (initialized)
	{
		initialized = init(); 
		return initialized;
	}
	else
	{
		return isAvailable();
	}		
}
if (foo() && foo())
\end{lstlisting}
В приведенном выше примере вызов функции \textit{foo()} является необходимым и не соответствует ошибке, 
но анализатор не учитывает побочные эффекты (side effects) при вызове функции и выдает предупреждения.

Часто встречается наличие пустых веток \textit{if} и \textit{else}, которые появляются при использовании
макросов. Такая конструкция считается корректной и безопасной:
\begin{lstlisting}
if (exp) {} 
else {}
\end{lstlisting}
Но анализатор выдаст предупреждение, о совпадении веток \textit{if} и \textit{else}. Помимо 
ложного срабатывания при использовании пустых веток, часто анализатор выдает предупреждение для
кода:
\begin{lstlisting}
	if (err1)
		return -1;
	else if (err2)
		return -1;
	else
		return 0;
\end{lstlisting}
Приведенный код соответсвует следующему:
\begin{lstlisting}
	if (err1 || err2)
		return -1;
	else
		return 0;
\end{lstlisting}
Но для удобства читаемости исходного кода была использована конструкция \textit{if-else-if}. И так как
анализатор находит две одинаковые ветки (\textit{return -1;}), выдается предупреждение.
	
При использовании функции \textit{strlen} иногда необходимо подсчитать длину строки без первого
символа, для этого можно использовать конструкцию \textit{strlen(text+1)}, но с точки зрения анализатора,
данный участок кода содержит потенциальную ошибку и будет выдано предупреждение. Похожее ложное 
срабатывание происходит, когда необходимо выделить памяти для строки без учета символа '\\0'. 
	
\subsection*{Ошибки второго рода}
Реализованный модуль для статических проверок построен на основе сопоставления участков кода заранее
заданным шаблонам, которые соответствуют фрагментам кода, потенциально содержащим ошибки.
Вследствие чего, эффективность нахождения ошибок реализованного модуля зависит от количества запрограммированных шаблонов.
Однако реализованные проверки могут находить не все ошибки. Рассмотрим пример:
\begin{lstlisting}
if (( (A || B) && C) || ((A && C) || (A && B)))
\end{lstlisting}
Как видно, левая часть \textbf{( (A || B) \&\& C)} эквивалентна правой части \textbf{((A \&\& C) || (A \&\& B))}
оператора \textbf{||}, но анализатор не выдаст никаких предупреждений так как абстрактное синтаксическое дерево 
для левой и правой части различны. Поэтому при использовании кода, которые содержит ошибку, но не соответсвует шаблону,
предупреждение не будет выданно.
